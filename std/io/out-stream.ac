#file(access=public, namespace=io)

import .IOError;
import .reflect.Any;
import .reflect.Type;
import .reflect.StructTypeInfo;
import .reflect.EnumTypeInfo;
import .reflect.TypeId;

/*
 * A general purpose output stream for writing to files, sockets,
 * or any `Writable` handle.
 *
 * This stream is particularly helpful in that it has support for
 * outputting with different formats. As well it is capable of writing
 * any value of any type.
 */
generics(W) // TODO (maddie): add constraints for Writable once supported!
struct OutStream :: Writable {

    handle: W;

    fn new(handle: W) {
        this.handle #= moveobj(handle);
    }

    fn write_buffer(buffer: const char*, length: int) -> int | raises IOError {
        bytes_written := try (handle.write_buffer(buffer, length));
        return bytes_written;
    }

    fn write(s: const char*) | raises IOError {
        try (write_buffer(s, as(int) \strlen(s)));
    }

    fn write(s: const String^) | raises IOError {
        try (write_buffer(s.buffer, s.length));
    }

    fn write(value: int, base := 10) | raises IOError {
        value_u64 := as(uint64) value;
        if (value < 0) {
            try (write("-"));
            value_u64 = -(as(uint64) value);
        }

        try (write(value_u64, base));
    }

    fn write(value: uint64, base := 10) | raises IOError {

        BUFFER_SIZE :: 64;
        buffer: char[BUFFER_SIZE] = ---;
        ptr := \uint64_to_chars(value, buffer + BUFFER_SIZE - 1, base);

        length := as(int) ((buffer + BUFFER_SIZE) - ptr);
        try (write_buffer(ptr, length));
    }

    fn write(value: int64, base := 10) | raises IOError {
        value_u64 := as(uint64) value;
        if (value < 0) {
            try (write('-'));
            value_u64 = -(as(uint64) value);
        }

        try (write(value_u64, base));
    }

    fn write(c: char) | raises IOError {
        try (write_buffer(&c, 1));
    }

    fn write(b: bool) | raises IOError {
        if (b) {
            try (write_buffer("true", 4));
        } else {
            try (write_buffer("false", 5));
        }
    }

    fn write(value: Any) | raises IOError {
        try (write_any(value.ptr, value.type));
    }

    fn write(fmt: const char*, args: Any...) | raises IOError {
        arg_index := 0;
        loop (ptr := fmt; *ptr != '\0';) {
            if (*ptr == '%' && *(ptr+1) == 's') {
                ptr += 2;
                arg: Any = args[arg_index++];
                try (write(arg));
            } else {
                try (write(*ptr));
                ++ptr;
            }
        }
    }

    fn write(ptr: const void*) | raises IOError {

        BUFFER_SIZE :: sizeof(void*) * 2 + 2;
        buffer: char[BUFFER_SIZE] = ---;

        buffer_end := buffer + buffer.length - 1;
        int_ptr_start := \uint64_to_chars(as(uint64) ptr, buffer_end, base=16);

        zeros_length := as(int) (int_ptr_start - as(const char*) buffer);
        \memset(buffer, '0', zeros_length);
        buffer[1] = 'x';

        try (write_buffer(buffer, buffer.length));

    }

    private fn write_any(ptr: const void*, type: const Type*) | raises IOError {
        switch (type.id) {
        case INT:     try (write(as(int64)  *as(const int*)    ptr));
        case INT8:    try (write(as(int64)  *as(const int8*)   ptr));
        case INT16:   try (write(as(int64)  *as(const int16*)  ptr));
        case INT32:   try (write(as(int64)  *as(const int32*)  ptr));
        case INT64:   try (write(as(int64)  *as(const int64*)  ptr));
        case ISIZE:   try (write(as(int64)  *as(const isize*)  ptr));
        case UINT8:   try (write(as(uint64) *as(const uint8*)  ptr));
        case UINT16:  try (write(as(uint64) *as(const uint16*) ptr));
        case UINT32:  try (write(as(uint64) *as(const uint32*) ptr));
        case UINT64:  try (write(as(uint64) *as(const uint64*) ptr));
        case USIZE:   try (write(as(uint64) *as(const usize*)  ptr));
        case CHAR:    try (write(*as(const char*) ptr));
        // Just write out the numeric value of the characters.
        case CHAR16:  try (write(as(uint64) *as(const char16*) ptr));
        // TODO: case Float32: case Float64:
        case BOOL:    try (write(*as(const bool*) ptr));
        case POINTER:
            if (type.elm_type.id == TypeId.CHAR) {
                try (write(*as(const (const char*)*) ptr));
            } elif (type.elm_type == #type_info(String) || type.elm_type == #type_info(const String)) {
                try (write(*as(const (const String*)*) ptr));
            } else {
                try (write(*as(const (const void*)*) ptr));
            }
        case FUNCTION: try (write(*as(const (const void*)*) ptr));
        case STRUCT:
            if (type == #type_info(String)) {
                try (write(as(const String*) ptr));
            } else {
                try (write_struct(ptr, type.struct_info));
            }
        case SLICE:

            length := *as(const int*)(ptr + sizeof(void*));
            elements := *as(const (const void*)*) ptr;

            try (write_array_like_value(elements, type.elm_type, length));

        case ARRAY: try (write_array_like_value(ptr, type.elm_type, type.array_length));
        case ENUM:  try (write_enum(ptr, type.enum_info));
        }
    }

    private fn write_array_like_value(array: const void*, elm_type: const Type*, length: int)
        | raises IOError {
        try (write('['));

        elm_byte_size: int = elm_type.size_in_bytes;
        loop (i in 0..<length) {
            offset_into_array: const void* = array + (i * elm_byte_size);

            if (elm_type.is_string()) try (write('"'));
            try (write_any(offset_into_array, elm_type));
            if (elm_type.is_string()) try (write('"'));

            if (i+1 != length) {
                try (write(", "));
            }
        }

        try (write(']'));
    }

    private fn write_struct(ptr: const void*, struct_info: const StructTypeInfo*)
        | raises IOError {

        try (write(struct_info.name));
        try (write("{ "));

        loop (i in 0..<struct_info.num_fields) {
            field_info := struct_info.fields + i;
            try (write(field_info.name));
            try (write("="));

            field_data: const void* = ptr + field_info.offset_in_bytes;

            try (write('"'));

            if (field_info.type.is_string()) try (write('"'));
            try (write_any(field_data, field_info.type));
            if (field_info.type.is_string()) try (write('"'));

            if (i+1 != struct_info.num_fields) {
                try (write(", "));
            }
        }

        try (write(" }"));
    }

    private fn write_enum(ptr: const void*, enum_info: const EnumTypeInfo*)
        | raises IOError {
        index: uint64;
        switch (enum_info.index_type.id) {
        case INT:     index = as(uint64) *as(const int*)    ptr;
        case INT8:    index = as(uint64) *as(const int8*)   ptr;
        case INT16:   index = as(uint64) *as(const int16*)  ptr;
        case INT32:   index = as(uint64) *as(const int32*)  ptr;
        case INT64:   index = as(uint64) *as(const int64*)  ptr;
        case ISIZE:   index = as(uint64) *as(const isize*)  ptr;
        case UINT8:   index = as(uint64) *as(const uint8*)  ptr;
        case UINT16:  index = as(uint64) *as(const uint16*) ptr;
        case UINT32:  index = as(uint64) *as(const uint32*) ptr;
        case UINT64:  index = as(uint64) *as(const uint64*) ptr;
        case USIZE:   index = as(uint64) *as(const usize*)  ptr;
        case CHAR:    index = as(uint64) *as(const char*)   ptr;
        case CHAR16:  index = as(uint64) *as(const char16*) ptr;
        }

        name := enum_info.get_value_name(index);
        try (write(name));
    }

    // -- writeln functions
    //
    // TODO (maddie): simplify this once we have generic constraints.

    fn writeln(ptr: const void*) | raises IOError {
        try (write(ptr));
        try (write("\n"));
    }

    fn writeln(s: const char*) | raises IOError {
        try (write(s));
        try (write("\n"));
    }

    fn writeln(value: int, base := 10) | raises IOError {
        try (write(value, base));
        try (write("\n"));
    }

    fn writeln(value: uint64, base := 10) | raises IOError {
        try (write(value, base));
        try (write("\n"));
    }

    fn writeln(value: int64, base := 10) | raises IOError {
        try (write(value, base));
        try (write("\n"));
    }

    fn writeln(c: char) | raises IOError {
        try (write(c));
        try (write("\n"));
    }

    fn writeln(b: bool) | raises IOError {
        try (write(b));
        try (write("\n"));
    }

    fn writeln(s: const String^) | raises IOError {
        try (write(s));
        try (write("\n"));
    }

    fn writeln(any: Any) | raises IOError {
        try (write(any));
        try (write("\n"));
    }

    fn writeln(fmt: const char*, args: Any...) | raises IOError {
        try (write(fmt, args));
        try (write("\n"));
    }
}