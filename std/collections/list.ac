#file(access=public)

import .OutOfBoundsError;

generics(T)
struct List {
    private  buckets:  T*;
    readonly length:   int = 0;
    private  capacity: int = 0;

    fn copyobj(o: const List*) {
        this.length   #= o.length;
        this.capacity #= o.length;

        this.buckets #= as(String*) malloc(o.length * sizeof(T));
        // TODO (maddie): We should have reflection support to only do this is
        // we know the object is not trivially copyable, otherwise it can just
        // use memcpy.
        loop (bucket, new_bucket := o.buckets, this.buckets;
              bucket < o.buckets + o.length;) {
            uninit_new (new_bucket, *bucket);
            ++bucket;
            ++new_bucket;
        }
    }

    fn moveobj(o: List*) {
        this.length   #= exchange(o.length, 0);
        this.capacity #= exchange(o.capacity, 0);
        this.buckets  #= exchange(o.buckets, null);
    }

    /*
     * Adds the `value` to the list allocating memory memory
     * if needed.
     */
    fn add(value: T) {
        if (length + 1 > capacity) {
            min_capacity := length + 1;
            new_capacity := min_capacity + min_capacity/2;
            ensure_capacity(new_capacity);
        }

        last_bucket := buckets + length;
        uninit_new (last_bucket, moveobj(value));
        ++length;
    }

    /*
     * Get the element into the list at `index`. */
    fn get(index: int) -> T^ {
        if (index < 0 || index >= length) {
            raise OutOfBoundsError{ "List index out of bounds" };
        }
        return buckets + index;
    }

    /*
     * Calls the destructors for the current elements and sets
     * the length to zero. However, it does not deallocate the
     * memory.
     */
    fn clear() {
        delete_buckets();
        length = 0;
    }

    /*
     * Ensures enough memory is allocated to store at least
     * `capacity` elements.
     */
    fn reserve(capacity: int) {
        if (capacity > this.capacity) {
            ensure_capacity(capacity);
        }
    }

    /*
     * Gets the first element in the list. */
    fn first() -> T^ {
        return buckets;
    }

    /*
     * Gets the last element in the list. */
    fn last() -> T^ {
        return buckets + (length - 1);
    }

    /*
     * Reduces the memory usage of the List by having the `capacity`
     * and length equal each other. */
    fn shrink() {
        ensure_capacity(this.length);
    }

    private fn ensure_capacity(new_capacity: int) {
        new_buckets := as(T*) malloc(new_capacity * sizeof(T));

        if (length != 0) {
            // TODO (maddie): We should have reflection support to only do this is
            // we know the object is not trivially moveable, otherwise it can just
            // use memcpy.
            loop (bucket, new_bucket := buckets, new_buckets;
                  bucket < buckets + length;) {
                uninit_new (new_bucket, moveobj(*bucket));
                ++bucket;
                ++new_bucket;
            }
        }

        free(buckets);
        buckets  = new_buckets;
        capacity = new_capacity;
    }

    private fn delete_buckets() {
        // TODO (maddie): We should have reflection support to only do this if
        // we know the object needs destruction.
        loop (bucket := buckets; bucket < buckets + length; ++bucket) {
            // we dont have a way of calling the destructor!
            delete (bucket);
        }
    }

    fn delete() {
        delete_buckets();
        free(buckets);
        buckets  = null;
        capacity = 0;
        length   = 0;
    }
}
