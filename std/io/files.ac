#file(access=public, namespace=io)

import .. module;
import .win32;
import .unix;
import .String;
import .IOError;
import .StateError;

#if OS_GROUP_UNIX
import .unix.Stat;
#endif

// TODO: We want to a flag to not truncate when writing.

/*
 * Flags that indicate how to open a file for
 * reading and writing.
 */
enum FileFlag :: uint32 {

    /*
     * Read from the file.
     */
    IN  = 0x0001,

    /*
     * Write to the file.
     */
    OUT = 0x0002,

    /*
    * More than once open instance of the
    * file can be opened and accessed at
    * the same time.
    */
    SHARE = 0x0004,

    /*
     * Creates the file if it does not exist.
     *
     * The default behavior is to override the
     * file it it exists. If you wish to append
     * to an existing file use `APPEND`.
     */
    CREATE = 0x0008,

    /*
     * Will append to an existing file or may be used
     * in conjunction with CREATE to create the file
     * if it does not exist and append to the new file.
     */
    APPEND = 0x0010,

    /*
     * If used in conjunction with `FileFlag::CREATE`
     * then it will create the file as a hidden file.
     *
     * However, if the file already exists it will not
     * modify it to be hidden.
     */
    HIDDEN = 0x0020,

    /*
     * If used in conjunction with `FileFlag::CREATE`
     * then it will create the file as a readonly file.
     *
     * However, if the file already exists it will not
     * modify it to be readonly.
     */
    READONLY = 0x0040

}

struct FileHandle :: Writable, Readable {

#if OS_GROUP_WINDOWS
    handle: void*;
#elif OS_GROUP_UNIX
    handle: int32;
#endif

    auto_close: bool;

#if OS_GROUP_WINDOWS
    fn new(handle: void*, auto_close := true) {
        this.handle     #= handle;
        this.auto_close #= auto_close;
    }
#elif OS_GROUP_UNIX
    fn new(handle: int32, auto_close := true) {
        this.handle     #= handle;
        this.auto_close #= auto_close;
    }
#endif

    fn moveobj(file_handle: FileHandle*) {
        this.handle     #= file_handle.handle;
        this.auto_close #= file_handle.auto_close;

#if OS_GROUP_WINDOWS
        file_handle.handle = null;
#elif OS_GROUP_UNIX
        file_handle.handle = 0;
#endif
        file_handle.auto_close = false;
    }

    const fn get_size() -> uint64 {
#if OS_GROUP_WINDOWS
        size: int64;
        if (win32.GetFileSizeEx(handle, &size) == 0) {
            err_msg := module.win32_error_code_to_string(win32.GetLastError(), String{"Failed to get file size"});
            raise StateError{ moveobj(err_msg) };
        }
        return as(uint64) size;
#elif OS_GROUP_UNIX
        // TODO: error handling!
        stats: Stat;
        if (unix.fstat(handle, &stats) == 0) {
            return as(int) stats.st_size;
        }
        return 0;
#endif
    }

    fn read_buffer(buffer: char*, length: int) -> int | raises IOError {
#if OS_GROUP_WINDOWS
        bytes_read: uint32;
        if (win32.ReadFile(handle, buffer, as(uint32) length, &bytes_read, null) == 0) {
            // EOF may return an error so just return the number of bytes read if we hit EOF.
            ec := win32.GetLastError();
            if (ec == win32.ERROR_HANDLE_EOF) {
                return length;
            }
            err_msg := module.win32_error_code_to_string(ec, pretext=String{"Failed to read from file handle"});
            raise IOError{ moveobj(err_msg) };
        }
        return as(int) bytes_read;
#elif OS_GROUP_UNIX
        // TODO (maddie): This needs to be in a loop.
        bytes_read: isize = unix.read(handle, buffer, as(usize) length);
        if (bytes_read == -1) {
            raise IOError{ "Failed to read from file handle" };
        }
        return as(int) bytes_read;
#endif
    }

    fn write_buffer(buffer: const char*, length: int) -> int | raises IOError {
#if OS_GROUP_WINDOWS
        bytes_written: uint32;
        if (win32.WriteFile(handle, buffer, as(uint32) length, &bytes_written, null) == 0) {
            raise IOError{ "Failed to write to file handle" };
        }
        return as(int) bytes_written;
#elif OS_GROUP_UNIX
        bytes_written: isize = unix.write(handle, buffer, as(usize) length);
        if (bytes_written == -1) {
            raise IOError{ "Failed to write to file handle" };
        }
        return as(int) bytes_written;
#endif
    }

    fn delete() {
        if (auto_close) {
            close();
        }
    }

    fn close() {
#if OS_GROUP_WINDOWS
        win32.CloseHandle(handle);
        handle = null;
#elif OS_GROUP_UNIX
        unix.close(handle);
#endif
    }
}

#if OS_GROUP_WINDOWS
fn win32_get_file_error(ec: uint32, pretext: const String^) -> String {
    switch (ec) {
    case win32.ERROR_FILE_NOT_FOUND:
    case win32.ERROR_PATH_NOT_FOUND:
        return module.format("%s. Path not found", pretext);
    case win32.ERROR_ACCESS_DENIED:
        return module.format("%s. Access denied", pretext);
    case win32.ERROR_FILE_EXISTS:
        return module.format("%s. Path already exists", pretext);
    case:
        return module.win32_error_code_to_string(ec, pretext);
    }
}

fn win32_get_file_error(pretext: const String^) -> String {
    return win32_get_file_error(win32.GetLastError(), pretext);
}
#endif

/*
 * Reads an entire file into a `String`. This function assumes the file size
 * read in can fit into a signed 32 bit integer.
 */
fn read_file(path: const Path^) -> String | raises IOError {
    handle := try (open_file(path, FileFlag.IN | FileFlag.SHARE));

    // Read the size and make sure we are not dealing with really big files.
    large_size := handle.get_size();
    if (large_size > 2147483647) {
        err_msg := module.format(
            "Could not read file: \"%s\" because the file size exceeded 2^31 bytes", path.to_utf8_string()
        );
        raise StateError{ moveobj(err_msg) };
    }

    size := as(int) large_size;

    buffer := as(char*) module.malloc(size + 1); // +1 for null terminator.
    bytes_read := try err: (handle.read_buffer(buffer, size)) {
        raise IOError{ module.format("Reading file: \"%s\": %s", path.to_utf8_string(), err.get_message()) };
    };

    if (bytes_read != size) {
        raise IOError{ module.format("Failed to read all bytes of file: \"%s\"", path.to_utf8_string()) };
    }

    buffer[size] = '\0'; // Adding null terminator.
    return String{ buffer, size, copy_buffer=false };
}

/*
 * Reads an entire file into a `String`. This function assumes the file size
 * read in can fit into a signed 32 bit integer.
 *
 * @param path a utf-8 path to a file or directory.
 */
fn read_file(path: const char*) -> String | raises IOError {
    contents := try (read_file(Path{ path }));
    return contents;
}

/*
 * Reads an entire file into a `String`. This function assumes the file size
 * read in can fit into a signed 32 bit integer.
 *
 * @param path a utf-8 path to a file or directory.
 */
fn read_file(path: const String^) -> String | raises IOError {
    contents := try (read_file(Path{ path.buffer }));
    return contents;
}

/*
 * Returns true if the file system has a file or
 * directory at the given path.
 */
fn path_exists(path: const Path^) -> bool {
#if OS_GROUP_WINDOWS
    temp_buffer := path.to_utf16_string_temporary();

    attribs: uint32 = win32.GetFileAttributesW(temp_buffer.buffer);
    return attribs != win32.INVALID_FILE_ATTRIBUTES;
#elif OS_GROUP_UNIX
    return unix.access(path, unix.F_OK) == 0;
#endif
}

/*
 * Returns true if the file system has a file or
 * directory at the given path.
 *
 * @param path a utf-8 path to a file or directory.
 */
fn path_exists(path: const char*) -> bool {
    return path_exists(Path{ path });
}

/*
 * Returns true if the file system has a file or
 * directory at the given path.
 *
 * @param path a utf-8 path to a file or directory.
 */
fn path_exists(path: const String^) -> bool {
    return path_exists(Path{ path.buffer });
}

/*
 * Returns true if the file system has a file but
 * is not a directory at the given path.
 */
fn file_exists(path: const Path^) -> bool | raises IOError {
#if OS_GROUP_WINDOWS
    temp_buffer := path.to_utf16_string_temporary();

    attribs: uint32 = win32.GetFileAttributesW(temp_buffer.buffer);
    if (attribs == win32.INVALID_FILE_ATTRIBUTES) {
        err_msg := win32_get_file_error(module.format("Checking if file exists: \"%s\"",
                                        path.to_utf8_string()));
        raise IOError{ moveobj(err_msg) };
    }

    return attribs != win32.INVALID_FILE_ATTRIBUTES &&
          (attribs &  win32.FILE_ATTRIBUTE_DIRECTORY) == 0;
#elif OS_GROUP_UNIX
    stats: Stat;
    if (unix.stat(path, &stats) == 0) {
        return !unix.__S_ISTYPE(stats.st_mode, unix.__S_IFDIR);
    }
    return false;
#endif
}

/*
 * Returns true if the file system has a file but
 * is not a directory at the given path.
 *
 * @param path a utf-8 path to a file or directory.
 */
fn file_exists(path: const char*) -> bool | raises IOError {
    exists := try (file_exists(Path{ path }));
    return exists;
}

/*
 * Returns true if the file system has a file but
 * is not a directory at the given path.
 *
 * @param path a utf-8 path to a file or directory.
 */
fn file_exists(path: const String^) -> bool | raises IOError {
    exists := try (file_exists(Path{ path.buffer }));
    return exists;
}

/*
 * Returns true if the file system has a directory
 * at the given path.
 *
 * @param path a utf-8 path to a file or directory.
 */
fn directory_exists(path: const Path^) -> bool {
#if OS_GROUP_WINDOWS
    temp_buffer := path.to_utf16_string_temporary();

    attribs: uint32 = win32.GetFileAttributesW(temp_buffer.buffer);
    return attribs != win32.INVALID_FILE_ATTRIBUTES &&
          (attribs &  win32.FILE_ATTRIBUTE_DIRECTORY) != 0;
#elif OS_GROUP_UNIX
    stats: Stat;
    if (unix.stat(path, &stats) == 0) {
        return unix.__S_ISTYPE(stats.st_mode, unix.__S_IFDIR);
    }
    return false;
#endif
}

/*
 * Returns true if the file system has a directory
 * at the given path.
 *
 * @param path a utf-8 path to a file or directory.
 */
fn directory_exists(path: const char*) -> bool {
    return directory_exists(Path{ path });
}

/*
 * Returns true if the file system has a directory
 * at the given path.
 *
 * @param path a utf-8 path to a file or directory.
 */
fn directory_exists(path: const String^) -> bool {
    return directory_exists(Path{ path.buffer });
}

/*
 * Creates the directory at the given path.
 *
 * This function will not raise an error if the directory
 * already exists.
 *
 * @return if it created the directory, false if it already exists.
 */
fn mkdir(path: const Path^) -> bool | raises IOError {
    // TODO: We will also want to pass a variable for creating
    //       the parent directories if the user wants.

#if OS_GROUP_WINDOWS
    temp_buffer := path.to_utf16_string_temporary();

    if (win32.CreateDirectoryW(temp_buffer.buffer, null) == 0) {
        ec := win32.GetLastError();
        if (ec == win32.ERROR_ALREADY_EXISTS) {
            // Do not raise an error when the directory already exists.
            return false;
        }

        err_msg := win32_get_file_error(ec, module.format("Failed to make directory: \"%s\"",
                                        path.to_utf8_string()));
        raise IOError{ moveobj(err_msg) };
    }

    return true;
#elif OS_GROUP_UNIX
    return unix.mkdir(path, 0775) == 0;
#endif
}

/*
 * Creates the directory at the given path.
 *
 * This function will not raise an error if the directory
 * already exists.
 *
 * @param path a utf-8 path to a file or directory.
 * @return if it created the directory, false if it already exists.
 */
fn mkdir(path: const char*) -> bool | raises IOError {
    newly_created := try (mkdir(Path{ path }));
    return newly_created;
}

/*
 * Creates the directory at the given path.
 *
 * This function will not raise an error if the directory
 * already exists.
 *
 * @param path a utf-8 path to a file or directory.
 * @return if it created the directory, false if it already exists.
 */
fn mkdir(path: const String^) -> bool | raises IOError {
    newly_created := try (mkdir(Path{ path.buffer }));
    return newly_created;
}

/*
 * Deletes the file or directory if it exists.
 *
 * If deleting a directory the directory must be
 * empty.
 */
fn remove_path(path: const Path^) | raises IOError {

#if OS_GROUP_WINDOWS
    temp_buffer := path.to_utf16_string_temporary();

    attribs: uint32 = win32.GetFileAttributesW(temp_buffer.buffer);

    sucess := true;
    if (attribs != win32.INVALID_FILE_ATTRIBUTES) {
        if ((attribs & win32.FILE_ATTRIBUTE_DIRECTORY) != 0) {
            // Removing directory.
            sucess = win32.RemoveDirectoryW(temp_buffer.buffer) != 0;
        } else {
            // Removing file.
            sucess = win32.DeleteFileW(temp_buffer.buffer) != 0;
        }
    } else {
        sucess = false;
    }

    if (!sucess) {
        raise IOError{ win32_get_file_error(module.format("Failed to remove path: \"%s\"", path)) };
    }
#elif OS_GROUP_UNIX
    return unix.remove(path) == 0;
#endif
}

/*
 * Deletes the file or directory if it exists.
 *
 * If deleting a directory the directory must be
 * empty.
 *
 * @param path a utf-8 path to a file or directory.
 */
fn remove_path(path: const char*) | raises IOError {
    try (remove_path(Path{ path }));
}

/*
 * Deletes the file or directory if it exists.
 *
 * If deleting a directory the directory must be
 * empty.
 *
 * @param path a utf-8 path to a file or directory.
 */
fn remove_path(path: const String^) | raises IOError {
    try (remove_path(Path{ path.buffer }));
}

fn open_file(path: const Path^, flags: FileFlag$) -> FileHandle | raises IOError {

#if OS_GROUP_WINDOWS
    access_flags: uint32 = 0;
    share_flags:  uint32 = 0;
    create_flags: uint32 = 0;
    attib_flags:  uint32 = 0;

    if (flags == 0) {
        access_flags = win32.GENERIC_ALL;
    }

    if ((flags & FileFlag.IN) != 0) {
        access_flags |= win32.GENERIC_READ;
    }

    if ((flags & FileFlag.APPEND) != 0) {
        access_flags |= win32.FILE_APPEND_DATA;
    } elif ((flags & FileFlag.OUT) != 0) {
        access_flags |= win32.GENERIC_WRITE;
    }

    if ((flags & FileFlag.SHARE) != 0) {
        share_flags |= win32.FILE_SHARE_READ;
    }

    if ((flags & FileFlag.CREATE) != 0) {
        if ((flags & FileFlag.APPEND) != 0) {
            create_flags |= win32.OPEN_ALWAYS;
        } else {
            // Windows is weird and none of the create options allow us to simply
            // overwrite the old file. We will simply remove the existing file if
            // it exists then create a new one.
            try (remove_path(path));
            create_flags |= win32.CREATE_NEW;
        }
    } else {
        create_flags |= win32.OPEN_EXISTING;
    }

    attib_flags = win32.FILE_ATTRIBUTE_NORMAL;
    if ((flags & FileFlag.CREATE) != 0 && (flags & FileFlag.HIDDEN) != 0) {
        attib_flags &= ~win32.FILE_ATTRIBUTE_NORMAL;
        attib_flags |= win32.FILE_ATTRIBUTE_HIDDEN;
    }
    if ((flags & FileFlag.CREATE) != 0 && (flags & FileFlag.READONLY) != 0) {
        attib_flags &= ~win32.FILE_ATTRIBUTE_NORMAL;
        attib_flags |= win32.FILE_ATTRIBUTE_READONLY;
    }

    temp_buffer := path.to_utf16_string_temporary();

    handle: void* = win32.CreateFileW(temp_buffer.buffer,
                                      access_flags,
                                      share_flags,
                                      null,
                                      create_flags,
                                      attib_flags,
                                      null);

    if (handle == win32.INVALID_HANDLE_VALUE) {
        err_msg := win32_get_file_error(module.format("Failed to open file: \"%s\"", path.to_utf8_string()));
        raise IOError{ moveobj(err_msg) };
    }

    return FileHandle{ handle };
#elif OS_GROUP_UNIX

    // TODO: O_LARGEFILE -- Allow working for large file sizes.
    // TODO: Add hidden file support
    // TODO: Add readonly file support

    os_flags: int32 = 0;
    os_mode: uint32 = 0;

    if ((flags & FileFlag.IN) != 0 && (flags & FileFlag.OUT) != 0) {
        os_flags |= unix.O_RDWR;
    } elif ((flags & FileFlag.IN) != 0) {
        os_flags |= unix.O_RDONLY;
    } elif ((flags & FileFlag.OUT) != 0) {
        os_flags |= unix.O_WRONLY;
    }

    if ((flags & FileFlag.APPEND) != 0) {
        os_flags |= unix.O_APPEND;
    } else {
        os_flags |= unix.O_TRUNC;
    }

    if ((flags & FileFlag.CREATE) != 0) {
        os_flags |= unix.O_CREAT;
        // 0666
        os_mode = unix.S_IRUSR | unix.S_IWUSR | unix.S_IRGRP |
                  unix.S_IWGRP | unix.S_IROTH | unix.S_IWOTH;
    }

    handle: int32 = unix.open(path, os_flags, os_mode);
    if (handle == -1) {
        raise IOError{ module.format("Failed to open file: \"%s\"", path) };
    }

    return FileHandle{ handle };
#endif
}

fn open_file(path: const char*, flags: FileFlag$) -> FileHandle | raises IOError {
    handle := try (open_file(Path{ path }, flags));
    return handle;
}

fn open_file(path: const String^, flags: FileFlag$) -> FileHandle | raises IOError {
    handle := try (open_file(Path{ path.buffer }, flags));
    return handle;
}
