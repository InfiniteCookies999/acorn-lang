#file(access=pub)

struct String {
    char* buffer;
    int   length;
    
    /*
     * Creates a String with a length of 0.
     */
    String() {
        buffer = "\0";
    }

    copyobj String(String* o) {
        this.length = o.length;
        this.buffer = as(char*) malloc(length + 1); // +1 for null terminator.
        memcpy(this.buffer, o.buffer, length + 1);
    }

    /*
     * Creates a String from a null terminated
     * character buffer.
     */
    String(const char* buffer) {
        this.length = strlen(buffer);
        this.buffer = as(char*) malloc(length + 1); // +1 for null terminator.
        memcpy(this.buffer, buffer, length + 1);
    }

    /*
     * Creates a String from a character buffer and an
     * explicit length. Because of the explicitly defined
     * length the buffer does not have to be null terminated.
     *
     * If the buffer is null terminated do not include the
     * null termination in the length.
     */
    String(const char* buffer, int length) {
        this.length = length;
        this.buffer = malloc(length + 1); // +1 for null terminator.
        memcpy(this.buffer, buffer, length);
        this.buffer[length] = '\0';
    }

    /*
     * Creates a String from a character buffer and
     * an explicit length. Because of the explicitly
     * defined length the buffer does not have to be
     * null terminated.
     *
     * If the buffer is null terminated do not include
     * the null termination in the length.
     *
     * @Param copy_buffer if true it allocates new memory
     *                    and copies the buffer over otherwise
     *                    the buffer is assumed to be already
     *                    allocated and null terminated.
     *                    It will also assume ownership over the
     *                    memory if set to true.
     */
    String(char* buffer, int length, bool copy_buffer = true) {
        this.length = length;
        if copy_buffer {
            this.buffer = as(char*) malloc(length + 1); // +1 for null terminator.
            memcpy(this.buffer, buffer, length);
            this.buffer[length] = '\0';
        } else {
            this.buffer = buffer;
        }
    }
}

/*
 * Converts a 64 bit unsigned integer to a string containing
 * the digits in the `base`.
 *
 * @value the value to convert to a String.
 * @base  the numeric base of the value. Defaults to 10.
 */
String to_string(uint64 value, int base = 10) {
    const BUFFER_SIZE = 21;
    char[BUFFER_SIZE] buffer;

    char* ptr = uint64_to_chars(value, buffer + BUFFER_SIZE - 1, base);
    int length = as(int)(buffer + BUFFER_SIZE) - as(int)ptr;

    return String{ ptr, length };
}

/*
 * Converts a 64 bit integer to a string containing the digits
 * in the `base`.
 *
 * @value the value to convert to a String.
 * @base  the numeric base of the value. Defaults to 10.
 */
String to_string(int64 value, int base = 10) {
    
    bool is_negative = value < 0;
    uint64 value_u64;
    if is_negative {
        // Casting to a 64 bit unsigned first because it should be garenteed
        // to have well defined behavior but not signed.
        value_u64 = -(as(uint64) value);
    } else {
        value_u64 = as(uint64) value;
    }

    const BUFFER_SIZE = 21 + 1;
    char[BUFFER_SIZE] buffer;

    char* ptr = uint64_to_chars(value_u64, buffer + BUFFER_SIZE - 1, base);
    int length = as(int)(buffer + BUFFER_SIZE) - as(int)ptr;

    if is_negative {
        --ptr;
        *ptr = '-';
        ++length;
    }

    return String{ ptr, length };   
}

String to_string(int value, int base = 10) {
    return to_string(as(int64) value, base);
}

String to_string(bool b) {
    if b {
        return String{ "true", 4 };
    } else {
        return String{ "false", 5 };
    }
}

String to_string(char c) {
    return String{ &c, 1 };
}