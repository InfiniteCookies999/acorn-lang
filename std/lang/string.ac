#file(access=pub)

prv const DEFAULT_STRING = "\0";

struct String {
    char* buffer;
    int   length;
    
    /*
     * Creates a String with a length of 0.
     */
    String() {
        buffer = DEFAULT_STRING;
    }

    copyobj String(String* o) {
        this.length = o.length;
        this.buffer = as(char*) malloc(length + 1); // +1 for null terminator.
        memcpy(this.buffer, o.buffer, length + 1);
    }

    moveobj String(String* o) {
        this.length = o.length;
        this.buffer = o.buffer;
        o.length = 0;
        o.buffer = DEFAULT_STRING;
    }

    /*
     * Creates a String from a null terminated
     * character buffer.
     */
    String(const char* buffer) {
        this.length = strlen(buffer);
        this.buffer = as(char*) malloc(length + 1); // +1 for null terminator.
        memcpy(this.buffer, buffer, length + 1);
    }

    /*
     * Creates a String from a character buffer and an
     * explicit length. Because of the explicitly defined
     * length the buffer does not have to be null terminated.
     *
     * If the buffer is null terminated do not include the
     * null termination in the length.
     */
    String(const char* buffer, int length) {
        this.length = length;
        this.buffer = malloc(length + 1); // +1 for null terminator.
        memcpy(this.buffer, buffer, length);
        this.buffer[length] = '\0';
    }

    /*
     * Creates a String from a character buffer and
     * an explicit length. Because of the explicitly
     * defined length the buffer does not have to be
     * null terminated.
     *
     * If the buffer is null terminated do not include
     * the null termination in the length.
     *
     * @Param copy_buffer if true it allocates new memory
     *                    and copies the buffer over otherwise
     *                    the buffer is assumed to be already
     *                    allocated and null terminated.
     *                    It will also assume ownership over the
     *                    memory if set to true.
     */
    String(char* buffer, int length, bool copy_buffer = true) {
        this.length = length;
        if copy_buffer {
            this.buffer = as(char*) malloc(length + 1); // +1 for null terminator.
            memcpy(this.buffer, buffer, length);
            this.buffer[length] = '\0';
        } else {
            this.buffer = buffer;
        }
    }

    /*
     * Returns a sub-string of this string which is in the range
     * of `begin_idx` and goes to the end of the string.
     */
    String substr(int begin_idx) {
        return substr(begin_idx, length);
    }

    /*
     * Returns a sub-string of this string which is in the range
     * of `begin_idx` and goes until `end_idx - 1`.
     */
    String substr(int begin_idx, int end_idx) {
        // TODO: error handling.
        
        int sublength = end_idx - begin_idx;
        if sublength == 0 {
            return String{};
        }

        if begin_idx == 0 && end_idx == length {
            return *this;
        }

        return String{ this.buffer + begin_idx, sublength };
    }

    ~String() {
        if buffer != DEFAULT_STRING { // Make sure it is not just referencing the global memory.
            free(buffer);
            length = 0;
            buffer = DEFAULT_STRING;
        }
    }
}

/*
 * Converts a 64 bit unsigned integer to a string containing
 * the digits in the `base`.
 *
 * @value the value to convert to a String.
 * @base  the numeric base of the value. Defaults to 10.
 */
String to_string(uint64 value, int base = 10) {
    const BUFFER_SIZE = 21;
    char[BUFFER_SIZE] buffer;

    char* ptr = uint64_to_chars(value, buffer + BUFFER_SIZE - 1, base);
    int length = as(int)(buffer + BUFFER_SIZE) - as(int)ptr;

    return String{ ptr, length };
}

/*
 * Converts a 64 bit integer to a string containing the digits
 * in the `base`.
 *
 * @value the value to convert to a String.
 * @base  the numeric base of the value. Defaults to 10.
 */
String to_string(int64 value, int base = 10) {
    
    bool is_negative = value < 0;
    uint64 value_u64;
    if is_negative {
        // Casting to a 64 bit unsigned first because it should be garenteed
        // to have well defined behavior but not signed.
        value_u64 = -(as(uint64) value);
    } else {
        value_u64 = as(uint64) value;
    }

    const BUFFER_SIZE = 21 + 1;
    char[BUFFER_SIZE] buffer;

    char* ptr = uint64_to_chars(value_u64, buffer + BUFFER_SIZE - 1, base);
    int length = as(int)(buffer + BUFFER_SIZE) - as(int)ptr;

    if is_negative {
        --ptr;
        *ptr = '-';
        ++length;
    }

    return String{ ptr, length };   
}

String to_string(int value, int base = 10) {
    return to_string(as(int64) value, base);
}

String to_string(bool b) {
    if b {
        return String{ "true", 4 };
    } else {
        return String{ "false", 5 };
    }
}

String to_string(char c) {
    return String{ &c, 1 };
}